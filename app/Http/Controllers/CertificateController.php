<?php

namespace App\Http\Controllers;

use App\Models\Certificate;
use App\Models\Course;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Response;
use Illuminate\Support\Facades\Log;
use Barryvdh\DomPDF\Facade\Pdf;
use Illuminate\Support\Str;

class CertificateController extends Controller
{
    public function create(Course $course)
    {
        $user = Auth::user();

        // Pastikan pengguna berhak mendapatkan sertifikat
        if (!$user->isEligibleForCertificate($course)) {
            return redirect()->route('dashboard')->with('error', 'Anda belum memenuhi syarat untuk mendapatkan sertifikat di kursus ini.');
        }

        // Cek apakah sertifikat sudah ada
        if ($user->hasCertificateForCourse($course)) {
            $certificate = $user->getCertificateForCourse($course);
            return redirect()->route('certificates.download', $certificate);
        }

        // Cek apakah data user sudah lengkap
        if (!$user->date_of_birth || !$user->institution_name || !$user->gender || !$user->occupation) {
            return redirect()->route('profile.edit')
                ->with('error', 'Silakan lengkapi data profil Anda terlebih dahulu untuk mendapatkan sertifikat.');
        }

        // Langsung generate sertifikat tanpa form
        return $this->generateCertificate($course);
    }

    private function generateCertificate(Course $course)
    {
        $user = Auth::user();
        $template = $course->certificateTemplate;

        if (!$template) {
            return redirect()->back()->with('error', 'Template sertifikat untuk kursus ini tidak ditemukan.');
        }

        try {
            // Generate kode unik sertifikat
            $certificateCode = Certificate::generateCertificateCode();

            // Buat record sertifikat dengan data dari user
            $certificate = Certificate::create([
                'user_id' => $user->id,
                'course_id' => $course->id,
                'certificate_template_id' => $template->id,
                'certificate_code' => $certificateCode,
                'issued_at' => now(),
                'date_of_birth' => $user->date_of_birth,
                'institution_name' => $user->institution_name,
                'gender' => $user->gender,
                'email' => $user->email,
                'occupation' => $user->occupation,
            ]);

            // Generate PDF menggunakan view render
            $pdf = Pdf::loadView('certificates.template-render', compact('certificate'))
                ->setPaper('a4', 'landscape')
                ->setOptions([
                    'dpi' => 150,
                    'defaultFont' => 'times',
                    'isHtml5ParserEnabled' => true,
                    'isRemoteEnabled' => false, // PENTING: ubah ke false
                    'isPhpEnabled' => true,
                ]);

            $certificatesDir = 'certificates';
            if (!Storage::disk('public')->exists($certificatesDir)) {
                Storage::disk('public')->makeDirectory($certificatesDir);
            }

            $fileName = $certificateCode . '.pdf';
            $filePath = $certificatesDir . '/' . $fileName;
            Storage::disk('public')->put($filePath, $pdf->output());

            // Update record sertifikat dengan path file
            $certificate->update(['path' => $filePath]);

            Log::info("Certificate generated by user for self: user {$user->id}, course {$course->id}, file: {$filePath}");

            // Arahkan pengguna untuk langsung mengunduh sertifikatnya
            $successMessage = 'Sertifikat untuk kursus "' . $course->title . '" berhasil dibuat! ' .
                'Anda dapat mengunduhnya dari <a href="' . route('certificates.index') . '" class="text-blue-600 hover:text-blue-800 underline">halaman sertifikat</a> ' .
                'atau <a href="' . route('certificates.download', $certificate) . '" class="text-green-600 hover:text-green-800 underline">klik di sini untuk mengunduh langsung</a>.';

            return redirect()->route('dashboard')->with('success', $successMessage);
        } catch (\Exception $e) {
            Log::error("Certificate generation failed for user {$user->id} in course {$course->id}: " . $e->getMessage());
            return redirect()->back()->with('error', 'Terjadi kesalahan saat membuat sertifikat. Silakan coba lagi.');
        }
    }
    /**
     * Static method untuk generate certificate - dipanggil dari controller lain
     * TAMBAHAN: Method yang hilang ini yang menyebabkan error
     */
    public static function generateForUser(Course $course, User $user)
    {
        try {
            // Log untuk debugging
            Log::info("Attempting to generate certificate for user {$user->id} in course {$course->id}");

            // Cek apakah course punya template
            if (!$course->certificate_template_id) {
                Log::info("No certificate template set for course {$course->id}");
                return null;
            }

            // Cek apakah sertifikat sudah ada
            $existingCertificate = Certificate::where('course_id', $course->id)
                ->where('user_id', $user->id)
                ->first();

            if ($existingCertificate) {
                Log::info("Certificate already exists for user {$user->id} in course {$course->id}");
                return $existingCertificate;
            }

            // Panggil ProgressController untuk generate certificate
            $progressController = new \App\Http\Controllers\ProgressController();
            $reflection = new \ReflectionClass($progressController);
            $method = $reflection->getMethod('generateCertificate');
            $method->setAccessible(true);

            $certificate = $method->invoke($progressController, $course, $user);

            if ($certificate) {
                Log::info("Certificate generated successfully for user {$user->id} in course {$course->id}");
                return $certificate;
            } else {
                Log::warning("Failed to generate certificate for user {$user->id} in course {$course->id}");
                return null;
            }
        } catch (\Exception $e) {
            Log::error("Error generating certificate for user {$user->id} in course {$course->id}: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Display user's certificates
     */
    public function index()
    {
        $user = Auth::user();

        $certificates = Certificate::where('user_id', $user->id)
            ->with(['course', 'certificateTemplate'])
            ->orderBy('issued_at', 'desc')
            ->paginate(10);

        return view('certificates.index', compact('certificates'));
    }

    /**
     * Show specific certificate for authenticated user
     */
    public function show(Certificate $certificate)
    {
        $this->authorize('view', $certificate);

        $certificate->load(['course', 'user', 'certificateTemplate']);

        return view('certificates.show', compact('certificate'));
    }

    /**
     * Show specific certificate for authenticated user
     */
    public function publicShow(Certificate $certificate)
    {

        $certificate->load(['course', 'user', 'certificateTemplate']);

        return view('certificates.show', compact('certificate'));
    }

    /**
     * Download certificate PDF
     */
    public function download(Certificate $certificate)
    {
        $this->authorize('view', $certificate);

        if (!$certificate->fileExists()) {
            return back()->with('error', 'File sertifikat tidak ditemukan.');
        }

        $fileName = 'Sertifikat-' . Str::slug($certificate->course->title) . '-' . Str::slug($certificate->user->name) . '.pdf';

        return Storage::disk('public')->download($certificate->path, $fileName);
    }

    /**
     * Public certificate verification (no auth required)
     */
    public function verify($code)
    {
        $certificate = Certificate::where('certificate_code', $code)
            ->with(['user', 'course', 'certificateTemplate'])
            ->first();

        if (!$certificate) {
            return view('certificates.verify-error')->with('error', 'Kode sertifikat tidak valid.');
        }

        return view('certificates.show', compact('certificate'));
    }

    /**
     * Public download for verified certificate (no auth required)
     */
    public function publicDownload($code)
    {
        $certificate = Certificate::where('certificate_code', $code)->first();

        if (!$certificate || !$certificate->fileExists()) {
            abort(404, 'Sertifikat tidak ditemukan.');
        }

        $fileName = 'Certificate-' . $certificate->certificate_code . '.pdf';

        return Storage::disk('public')->download($certificate->path, $fileName);
    }

    /**
     * Generate certificate manually (for admin/instructor)
     */
    public function generate(Request $request, Course $course, User $user)
    {
        $this->authorize('update', $course);

        // Check if user is enrolled
        if (!$course->enrolledUsers()->where('user_id', $user->id)->exists()) {
            return back()->with('error', 'User tidak terdaftar dalam kursus ini.');
        }

        // Check if certificate already exists
        $existingCertificate = Certificate::where('course_id', $course->id)
            ->where('user_id', $user->id)
            ->first();

        if ($existingCertificate) {
            return back()->with('error', 'Sertifikat untuk user ini sudah ada.');
        }

        // Check if course has template
        if (!$course->certificate_template_id) {
            return back()->with('error', 'Kursus belum memiliki template sertifikat.');
        }

        try {
            // Use the same logic as ProgressController
            $progressController = new \App\Http\Controllers\ProgressController();
            $reflection = new \ReflectionClass($progressController);
            $method = $reflection->getMethod('generateCertificate');
            $method->setAccessible(true);

            $certificate = $method->invoke($progressController, $course, $user);

            if ($certificate) {
                return back()->with('success', 'Sertifikat berhasil dibuat untuk ' . $user->name);
            } else {
                return back()->with('error', 'Gagal membuat sertifikat.');
            }
        } catch (\Exception $e) {
            return back()->with('error', 'Terjadi kesalahan: ' . $e->getMessage());
        }
    }

    /**
     * Regenerate certificate (delete old and create new)
     */
    public function regenerate(Certificate $certificate)
    {
        $this->authorize('update', $certificate->course);

        try {
            $course = $certificate->course;
            $user = $certificate->user;

            // Delete old certificate file
            if ($certificate->fileExists()) {
                Storage::disk('public')->delete($certificate->path);
            }

            // Delete old certificate record
            $certificate->delete();

            // Generate new certificate
            $progressController = new \App\Http\Controllers\ProgressController();
            $reflection = new \ReflectionClass($progressController);
            $method = $reflection->getMethod('generateCertificate');
            $method->setAccessible(true);

            $newCertificate = $method->invoke($progressController, $course, $user);

            if ($newCertificate) {
                return back()->with('success', 'Sertifikat berhasil dibuat ulang.');
            } else {
                return back()->with('error', 'Gagal membuat ulang sertifikat.');
            }
        } catch (\Exception $e) {
            return back()->with('error', 'Terjadi kesalahan: ' . $e->getMessage());
        }
    }

    /**
     * Delete certificate
     */
    public function destroy(Certificate $certificate)
    {
        $this->authorize('delete', $certificate);

        try {
            // Delete file if exists
            if ($certificate->fileExists()) {
                Storage::disk('public')->delete($certificate->path);
            }

            // Delete record
            $certificate->delete();

            return back()->with('success', 'Sertifikat berhasil dihapus.');
        } catch (\Exception $e) {
            return back()->with('error', 'Gagal menghapus sertifikat: ' . $e->getMessage());
        }
    }

    /**
     * Get certificates for a specific course (for instructor view)
     */
    public function courseIndex(Course $course)
    {
        $this->authorize('viewProgress', $course);

        $certificates = Certificate::where('course_id', $course->id)
            ->with(['user', 'certificateTemplate'])
            ->orderBy('issued_at', 'desc')
            ->paginate(15);

        return view('certificates.course-index', compact('course', 'certificates'));
    }

    /**
     * Bulk generate certificates for all eligible users in a course
     */
    public function bulkGenerate(Course $course)
    {
        $this->authorize('update', $course);

        if (!$course->certificate_template_id) {
            return back()->with('error', 'Kursus belum memiliki template sertifikat.');
        }

        $eligibleUsers = [];
        $enrolledUsers = $course->enrolledUsers;

        foreach ($enrolledUsers as $user) {
            // Check if user meets criteria and doesn't already have certificate
            $progress = $user->courseProgress($course);
            $allGraded = $user->areAllGradedItemsMarked($course);
            $hasCertificate = Certificate::where('course_id', $course->id)
                ->where('user_id', $user->id)
                ->exists();

            if ($progress >= 100 && $allGraded && !$hasCertificate) {
                $eligibleUsers[] = $user;
            }
        }

        if (empty($eligibleUsers)) {
            return back()->with('info', 'Tidak ada peserta yang memenuhi syarat untuk mendapat sertifikat.');
        }

        $generated = 0;
        $progressController = new \App\Http\Controllers\ProgressController();
        $reflection = new \ReflectionClass($progressController);
        $method = $reflection->getMethod('generateCertificate');
        $method->setAccessible(true);

        foreach ($eligibleUsers as $user) {
            try {
                $certificate = $method->invoke($progressController, $course, $user);
                if ($certificate) {
                    $generated++;
                }
            } catch (\Exception $e) {
                \Log::error("Failed to generate certificate for user {$user->id}: " . $e->getMessage());
            }
        }

        return back()->with('success', "Berhasil membuat {$generated} sertifikat dari " . count($eligibleUsers) . " peserta yang memenuhi syarat.");
    }

    /**
     * Certificate Management Index - Main dashboard
     */
    public function managementIndex(Request $request)
    {
        $this->authorize('viewAny', Certificate::class);

        $query = Certificate::with(['user', 'course', 'certificateTemplate']);

        // Filter by course
        if ($request->has('course_id') && $request->course_id) {
            $query->where('course_id', $request->course_id);
        }

        // Filter by name
        if ($request->has('search') && $request->search) {
            $search = $request->search;
            $query->whereHas('user', function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%");
            });
        }

        $certificates = $query->orderBy('issued_at', 'desc')->paginate(15);
        $courses = Course::whereHas('certificates')->with('certificates')->get();
        $templates = \App\Models\CertificateTemplate::orderBy('name')->get();

        // Analytics data
        $analytics = [
            'total_certificates' => Certificate::count(),
            'certificates_this_month' => Certificate::whereMonth('issued_at', now()->month)
                ->whereYear('issued_at', now()->year)
                ->count(),
            'courses_with_certificates' => Course::whereHas('certificates')->count(),
            'recent_certificates' => Certificate::with(['user', 'course'])
                ->orderBy('issued_at', 'desc')
                ->limit(5)
                ->get()
        ];

        return view('certificate-management.index', compact('certificates', 'courses', 'templates', 'analytics'));
    }

    /**
     * Analytics dashboard
     */
    public function analytics()
    {
        $this->authorize('viewAny', Certificate::class);

        // Monthly certificate generation stats
        $monthlyStats = Certificate::selectRaw('YEAR(issued_at) as year, MONTH(issued_at) as month, COUNT(*) as count')
            ->groupBy('year', 'month')
            ->orderBy('year', 'desc')
            ->orderBy('month', 'desc')
            ->limit(12)
            ->get();

        // Course-wise statistics
        $courseStats = Course::withCount('certificates')
            ->having('certificates_count', '>', 0)
            ->orderBy('certificates_count', 'desc')
            ->limit(10)
            ->get();

        // Template usage statistics
        $templateStats = \App\Models\CertificateTemplate::withCount('certificates')
            ->having('certificates_count', '>', 0)
            ->orderBy('certificates_count', 'desc')
            ->get();

        $analytics = [
            'total_certificates' => Certificate::count(),
            'total_courses_with_certificates' => Course::whereHas('certificates')->count(),
            'total_templates' => \App\Models\CertificateTemplate::count(),
            'certificates_today' => Certificate::whereDate('issued_at', today())->count(),
            'certificates_this_week' => Certificate::whereBetween('issued_at', [now()->startOfWeek(), now()->endOfWeek()])->count(),
            'certificates_this_month' => Certificate::whereMonth('issued_at', now()->month)
                ->whereYear('issued_at', now()->year)
                ->count(),
        ];
        
        // Demographic & market analytics from certificate form fields
        $genderStats = Certificate::selectRaw('gender, COUNT(*) as total')
            ->whereNotNull('gender')
            ->groupBy('gender')
            ->pluck('total', 'gender');

        $dobCertificates = Certificate::whereNotNull('date_of_birth')->get(['date_of_birth']);
        $ageGroups = [
            '<=18' => 0,
            '19-24' => 0,
            '25-34' => 0,
            '35-44' => 0,
            '45-54' => 0,
            '55+' => 0,
        ];
        foreach ($dobCertificates as $c) {
            if (!$c->date_of_birth) continue;
            $age = $c->date_of_birth->age;
            if ($age <= 18) $ageGroups['<=18']++;
            elseif ($age <= 24) $ageGroups['19-24']++;
            elseif ($age <= 34) $ageGroups['25-34']++;
            elseif ($age <= 44) $ageGroups['35-44']++;
            elseif ($age <= 54) $ageGroups['45-54']++;
            else $ageGroups['55+']++;
        }

        $topOccupations = Certificate::selectRaw('occupation, COUNT(*) as total')
            ->whereNotNull('occupation')
            ->where('occupation', '!=', '')
            ->groupBy('occupation')
            ->orderByDesc('total')
            ->limit(10)
            ->get();

        $topInstitutions = Certificate::selectRaw('institution_name, COUNT(*) as total')
            ->whereNotNull('institution_name')
            ->where('institution_name', '!=', '')
            ->groupBy('institution_name')
            ->orderByDesc('total')
            ->limit(10)
            ->get();

        $emails = Certificate::whereNotNull('email')->pluck('email');
        $domainCounts = [];
        foreach ($emails as $email) {
            $parts = explode('@', strtolower(trim($email)));
            if (count($parts) === 2) {
                $domain = $parts[1];
                $domainCounts[$domain] = ($domainCounts[$domain] ?? 0) + 1;
            }
        }
        arsort($domainCounts);
        $topEmailDomains = collect($domainCounts)
            ->take(10)
            ->map(function ($count, $domain) {
                return ['domain' => $domain, 'total' => $count];
            })->values();

        return view('certificate-management.analytics', compact(
            'analytics', 'monthlyStats', 'courseStats', 'templateStats',
            'genderStats', 'ageGroups', 'topOccupations', 'topInstitutions', 'topEmailDomains'
        ));
    }

    /**
     * Show certificates by course
     */
    public function byCourse(Course $course, Request $request)
    {
        $this->authorize('viewAny', Certificate::class);

        $query = Certificate::where('course_id', $course->id)
            ->with(['user', 'certificateTemplate']);

        // Filter by name
        if ($request->has('search') && $request->search) {
            $search = $request->search;
            $query->whereHas('user', function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%");
            });
        }

        $certificates = $query->orderBy('issued_at', 'desc')->paginate(15);
        $templates = \App\Models\CertificateTemplate::orderBy('name')->get();

        return view('certificate-management.by-course', compact('course', 'certificates', 'templates'));
    }

    /**
     * Bulk download certificates as ZIP
     */
    public function bulkDownload(Request $request)
    {
        $request->validate([
            'certificate_ids' => 'required|array',
            'certificate_ids.*' => 'exists:certificates,id'
        ]);

        $certificates = Certificate::whereIn('id', $request->certificate_ids)
            ->with(['user', 'course'])
            ->get();

        // Check if user can download all certificates
        foreach ($certificates as $certificate) {
            $this->authorize('view', $certificate);
        }

        // Create temporary directory for ZIP
        $tempDir = storage_path('app/temp/certificates_' . uniqid());
        if (!file_exists($tempDir)) {
            mkdir($tempDir, 0755, true);
        }

        $zipFileName = 'certificates_' . now()->format('Y-m-d_His') . '.zip';
        $zipFilePath = $tempDir . '/' . $zipFileName;

        try {
            $zip = new \ZipArchive();
            if ($zip->open($zipFilePath, \ZipArchive::CREATE | \ZipArchive::OVERWRITE) !== true) {
                throw new \Exception('Could not create ZIP file');
            }

            $addedFiles = 0;
            foreach ($certificates as $certificate) {
                if ($certificate->fileExists()) {
                    $pdfPath = Storage::disk('public')->path($certificate->path);
                    $fileName = 'Sertifikat-' .
                        Str::slug($certificate->course->title) . '-' .
                        Str::slug($certificate->user->name) . '-' .
                        $certificate->certificate_code . '.pdf';

                    if ($zip->addFile($pdfPath, $fileName)) {
                        $addedFiles++;
                    }
                }
            }

            $zip->close();

            if ($addedFiles === 0) {
                // Clean up and return error
                @unlink($zipFilePath);
                @rmdir($tempDir);
                return back()->with('error', 'Tidak ada file sertifikat yang valid untuk diunduh.');
            }

            // Download the ZIP file
            return response()->download($zipFilePath, $zipFileName)->deleteFileAfterSend(true);

        } catch (\Exception $e) {
            Log::error("Bulk download failed: " . $e->getMessage());
            // Clean up
            if (file_exists($zipFilePath)) {
                @unlink($zipFilePath);
            }
            if (file_exists($tempDir)) {
                @rmdir($tempDir);
            }
            return back()->with('error', 'Gagal membuat file ZIP: ' . $e->getMessage());
        }
    }

    /**
     * Bulk actions for certificates
     */
    public function bulkAction(Request $request)
    {
        $this->authorize('update', Certificate::class);

        $request->validate([
            'action' => 'required|in:delete,update_template,download',
            'certificate_ids' => 'required|array',
            'certificate_ids.*' => 'exists:certificates,id'
        ]);

        // Handle download action separately (returns file download)
        if ($request->action === 'download') {
            return $this->bulkDownload($request);
        }

        $certificates = Certificate::whereIn('id', $request->certificate_ids)->get();

        if ($request->action === 'delete') {
            foreach ($certificates as $certificate) {
                // Delete file if exists
                if ($certificate->fileExists()) {
                    Storage::disk('public')->delete($certificate->path);
                }
                $certificate->delete();
            }

            return response()->json([
                'success' => true,
                'message' => 'Berhasil menghapus ' . count($certificates) . ' sertifikat.'
            ]);
        }

        if ($request->action === 'update_template') {
            $updated = 0;
            foreach ($certificates as $certificate) {
                try {
                    // Regenerate certificate with current template
                    $course = $certificate->course;
                    $user = $certificate->user;

                    // Delete old file
                    if ($certificate->fileExists()) {
                        Storage::disk('public')->delete($certificate->path);
                    }

                    // Generate new PDF
                    $pdf = Pdf::loadView('certificates.template-render', compact('certificate'))
                        ->setPaper('a4', 'landscape')
                        ->setOptions([
                            'dpi' => 150,
                            'defaultFont' => 'times',
                            'isHtml5ParserEnabled' => true,
                            'isRemoteEnabled' => false,
                            'isPhpEnabled' => true,
                        ]);

                    $fileName = $certificate->certificate_code . '.pdf';
                    $filePath = 'certificates/' . $fileName;
                    Storage::disk('public')->put($filePath, $pdf->output());

                    $certificate->update(['path' => $filePath]);
                    $updated++;
                } catch (\Exception $e) {
                    \Log::error("Failed to update certificate {$certificate->id}: " . $e->getMessage());
                }
            }

            return response()->json([
                'success' => true,
                'message' => "Berhasil memperbarui {$updated} dari " . count($certificates) . " sertifikat."
            ]);
        }
    }

    /**
     * Update certificate template manually
     */
    public function updateTemplate(Request $request, Certificate $certificate)
    {
        $this->authorize('update', $certificate);

        // Validate request if new template is provided
        $request->validate([
            'certificate_template_id' => 'nullable|exists:certificate_templates,id'
        ]);

        try {
            // If new template is provided, update the certificate's template
            if ($request->has('certificate_template_id') && $request->certificate_template_id) {
                $certificate->update([
                    'certificate_template_id' => $request->certificate_template_id
                ]);
                // Reload the certificate to get the new template relationship
                $certificate = $certificate->fresh(['certificateTemplate']);
            }

            // Check if template exists
            if (!$certificate->certificateTemplate) {
                return back()->with('error', 'Template sertifikat tidak ditemukan.');
            }

            // Delete old file
            if ($certificate->fileExists()) {
                Storage::disk('public')->delete($certificate->path);
            }

            // Generate new PDF with current/new template
            $pdf = Pdf::loadView('certificates.template-render', compact('certificate'))
                ->setPaper('a4', 'landscape')
                ->setOptions([
                    'dpi' => 150,
                    'defaultFont' => 'times',
                    'isHtml5ParserEnabled' => true,
                    'isRemoteEnabled' => false,
                    'isPhpEnabled' => true,
                ]);

            $fileName = $certificate->certificate_code . '.pdf';
            $filePath = 'certificates/' . $fileName;
            Storage::disk('public')->put($filePath, $pdf->output());

            $certificate->update(['path' => $filePath]);

            $message = $request->has('certificate_template_id') && $request->certificate_template_id
                ? 'Sertifikat berhasil diperbarui dengan template baru.'
                : 'Sertifikat berhasil diperbarui dengan template terbaru.';

            return back()->with('success', $message);
        } catch (\Exception $e) {
            \Log::error("Failed to update certificate template for {$certificate->id}: " . $e->getMessage());
            return back()->with('error', 'Gagal memperbarui sertifikat: ' . $e->getMessage());
        }
    }

    /**
     * Start bulk download all certificates with filters (async)
     */
    public function downloadAll(Request $request)
    {
        $this->authorize('viewAny', Certificate::class);

        $request->validate([
            'course_id' => 'nullable|exists:courses,id',
            'search' => 'nullable|string|max:255'
        ]);

        // Generate unique batch ID
        $batchId = 'bulk_' . uniqid() . '_' . now()->timestamp;

        // Dispatch job to handle the download in background
        \App\Jobs\BulkDownloadCertificatesJob::dispatch(
            $batchId,
            $request->course_id,
            $request->search
        );

        return response()->json([
            'success' => true,
            'batch_id' => $batchId,
            'message' => 'Download sedang diproses. Harap tunggu...'
        ]);
    }

    /**
     * Check download status
     */
    public function downloadStatus($batchId)
    {
        $statusFile = storage_path('app/temp/download_status_' . $batchId . '.json');

        if (!file_exists($statusFile)) {
            return response()->json([
                'status' => 'not_found',
                'message' => 'Status tidak ditemukan'
            ], 404);
        }

        $status = json_decode(file_get_contents($statusFile), true);

        return response()->json($status);
    }

    /**
     * Download the prepared ZIP file
     */
    public function downloadZip($batchId)
    {
        $this->authorize('viewAny', Certificate::class);

        $statusFile = storage_path('app/temp/download_status_' . $batchId . '.json');

        if (!file_exists($statusFile)) {
            abort(404, 'Download tidak ditemukan');
        }

        $status = json_decode(file_get_contents($statusFile), true);

        if ($status['status'] !== 'completed' || !isset($status['zip_path'])) {
            abort(400, 'Download belum selesai atau gagal');
        }

        $zipPath = $status['zip_path'];

        if (!file_exists($zipPath)) {
            abort(404, 'File ZIP tidak ditemukan');
        }

        // Get the filename from path
        $zipFileName = basename($zipPath);

        // Download and schedule cleanup
        return response()->download($zipPath, $zipFileName)->deleteFileAfterSend(true);
    }

    /**
     * Cleanup old download files (can be scheduled)
     */
    public function cleanupDownloads()
    {
        $tempDir = storage_path('app/temp');

        if (!is_dir($tempDir)) {
            return;
        }

        $files = glob($tempDir . '/*');
        $now = time();
        $maxAge = 3600; // 1 hour

        foreach ($files as $file) {
            if (is_file($file) && ($now - filemtime($file) > $maxAge)) {
                @unlink($file);
            } elseif (is_dir($file) && ($now - filemtime($file) > $maxAge)) {
                // Remove directory and its contents
                array_map('unlink', glob($file . '/*'));
                @rmdir($file);
            }
        }
    }
}
